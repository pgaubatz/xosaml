package provide xoXSD::SchemaGenerator 0.1

package require tdom
package require struct::set
package require XOTcl
package require xoXSD::SchemaGenerator::Parser

namespace import -force ::xotcl::*

namespace eval ::xoXSD {

::xotcl::Class SchemaGenerator -slots {
	::xotcl::Attribute xoNamespacePrefix
	::xotcl::Attribute parsers
}

SchemaGenerator instproc init {ns} {
	my parsers [list]
	my xoNamespacePrefix $ns
}

SchemaGenerator instproc getTargetPrefix {document} {
	set xoNamespaces() ""
	set xoTargetNamespace [$document getAttribute "targetNamespace"]
	
	foreach attr [$document attributes "xmlns:*"] {
		set prefix [lindex $attr 0]
		set attr "xmlns:$prefix"
		set ns [$document getAttribute $attr]
		set xoNamespaces($prefix) $ns
		set xoNamespaces($ns) $prefix
	}
	
	return $xoNamespaces($xoTargetNamespace)
}

SchemaGenerator instproc addSchema {data} {
	if { [my xoNamespacePrefix] eq "" } {
		puts "ERROR: A namespace has to be defined before! (via \"setNamespace\")"
		return
	}	
	
	set doc [dom parse $data] 
	set root [$doc documentElement]
	set targetPrefix [my getTargetPrefix $root]
	set targetNamespace [$root getAttribute "targetNamespace"]
	
	if { [$root nodeName] ne "schema" } {
		error "ERROR: $filename is not an XML schema file."
	}

	my lappend parsers [::xoXSD::SchemaGenerator::Parser::parse $root $targetPrefix $targetNamespace [my xoNamespacePrefix]]
}

SchemaGenerator instproc generateSchema {} {
	set o ""
	append o "package require XOTcl\n"
	append o "package require xoXSD\n\n"
	append o "namespace import -force ::xoXSD::Slots::*\n\n"
	foreach parser [my parsers] {
		append o [$parser getDummyClasses]
	}
	foreach parser [my parsers] {
		append o [$parser getClasses]
	}
	return $o
}

SchemaGenerator instproc generateEnvironment {} {
	set o "package require xoXSD::DataTypes\n\n"
	append o "namespace eval [my xoNamespacePrefix]\::Environment \{\n\n"
	append o "proc load \{targetNamespace\} \{\n\n"
	append o "::xoXSD::DataTypes::load \$targetNamespace\n\n"
	append o "namespace eval \$targetNamespace \{\n\n"
	
	foreach parser [my parsers] {
		append o "namespace import -force [$parser getNamespace]\::*\n"
	}
	append o "\n"
	
	# this procedure is needed to identify ambiguous classnames, i.e. when two 
	# different classes in two different namespaces have exactly the same name: 
	append o "# These classes are ambiguous, so you always have to properly namespace them:\n"
	set classnames [list]
	set ambiguous [list]
	foreach parser [my parsers] {
		set names [lsort -unique [$parser getClassNames]]
		set intersect [::struct::set intersect $classnames $names]
		::struct::set add ambiguous $intersect
		::struct::set subtract names $intersect
		::struct::set add classnames $names
	}
	foreach a $ambiguous {
		foreach parser [my parsers] {
			append o "namespace forget [$parser getNamespace]::$a\n"
		}
	}
	append o "\n"
	
	foreach parser [my parsers] {
		append o [$parser getInterpAliases]
	}
	
	append o "\n\}\n\}\n\}\n"
	return $o
}

}

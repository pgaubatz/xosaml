package provide xoXSD::Generator::Parser 0.1

package require tdom
package require XOTcl
package require xoXSD::Generator::Virtual

namespace eval ::xoXSD::Generator::Parser {

proc parse {document targetprefix targetnamespace {prefix ""}} {
	set parser [::xoXSD::Generator::Parser::schema new $document]
	$parser xoTargetPrefix $targetprefix
	$parser xoNamespacePrefix $prefix
	$parser xoTargetNamespace $targetnamespace
	$parser realInit
	return $parser
}

::xotcl::Class Container -slots {
	::xotcl::Attribute node
	::xotcl::Attribute parent
	::xotcl::Attribute children
	::xotcl::Attribute root
	::xotcl::Attribute name -default ""
	::xotcl::Attribute xoclass
}
	
::xotcl::Class schema		-superclass Container -slots {
	::xotcl::Attribute xoClasses
	::xotcl::Attribute xoNamespacePrefix -default ""
	::xotcl::Attribute xoTargetPrefix
	::xotcl::Attribute xoTargetNamespace
	::xotcl::Attribute simpleTypes
}
	
::xotcl::Class element		-superclass Container
::xotcl::Class attribute	-superclass Container 
::xotcl::Class complexType	-superclass Container 
::xotcl::Class sequence		-superclass Container -slots {
	::xotcl::Attribute counter -default 10
}
::xotcl::Class extension	-superclass Container
::xotcl::Class complexContent	-superclass Container
::xotcl::Class choice		-superclass Container
::xotcl::Class enumeration	-superclass Container
::xotcl::Class any		-superclass Container
::xotcl::Class restriction	-superclass Container
::xotcl::Class import		-superclass Container
::xotcl::Class attributeGroup	-superclass Container 
::xotcl::Class simpleType	-superclass Container -slots {
	::xotcl::Attribute base
	::xotcl::Attribute enumvalues -default false
}
::xotcl::Class simpleContent	-superclass Container
::xotcl::Class anyAttribute	-superclass Container




Container instproc init {node {parent ""} {root ""}} {
	my node $node
	my parent $parent
	my root $root
	if { $root == "" } {
		my root [self]	
	}
	
	#puts "INIT -> [$node nodeName] SELF=[self] PARENT=[my parent] ROOT=[my root]"
	
	foreach node [[my node] childNodes] {
		set type [$node nodeName]
		
		if { $type == "annotation" } continue
		if { $type == "documentation" } continue
		if { $type == "#text" } continue
		
		eval ::xoXSD::Generator::Parser::$type new -childof [self] $node [self] [my root]
	}
	
	my children [my info children]
}
	
Container instproc getXMLName {xmlname} {
	if { [string first : $xmlname] != -1 } {
		set tmp [split $xmlname ":"]
		return [lindex $tmp 1]
	}
	return $xmlname
}

Container instproc getXMLPrefix {xmlname} {
	if { [string first : $xmlname] != -1 } {
		set tmp [split $xmlname :]
		return [lindex $tmp 0]
	}
	return ""
}

Container instproc XMLNametoXOTclClass {xmlname} {
	set xoClasses [[my root] xoClasses]
	set xoNamespacePrefix [[my root] xoNamespacePrefix]
	set xoTargetPrefix [[my root] xoTargetPrefix]
	
	set name [my getXMLName $xmlname]
	
	if { [my getXMLPrefix $xmlname] != "" } {	
		set prefix [my getXMLPrefix $xmlname]
	} else {
		set prefix "::xoXSD::DataTypes"
		if { ![Object isobject "$prefix\::$name"] } {
			set prefix "$xoNamespacePrefix\::$xoTargetPrefix"
		} 			
	}
	
	return "$prefix\::$name"
}
	
Container instproc getNode {} {
	return [my node]	
}

Container instproc getAllChildren {} {
	set children [list]
	foreach child [my info children] {
		lappend children $child	
	}
	foreach child $children {
		set children [concat $children [$child getAllChildren]] 
	}
	return $children
}

Container instproc realInit args {}

Container instproc earlyInit args {}

Container instproc setNameByPrefix {prefix} {
	set xoClasses [[my root] xoClasses]
	set i 0
	while { [lsearch [lsort $xoClasses] "*\::$prefix$i"] != -1 } { incr i }
	my name "$prefix$i"
}

Container instproc xoClassCreate {name type} {
	if { $name == "" || $type == "" } {
		error "xoClassCreate: name and/or type is empty."
	}
	set xoClasses [[my root] xoClasses]
	my xoclass [::xoXSD::Generator::Virtual::xoClass $name $name $type]
	[my root] addClass [my xoclass]
	return [my xoclass]
}
	
Container instproc parentAddSlot {name type {xmltype ""}} {
	if { $name == "" || $type == "" } {
		error "parentAddSlot: name and/or type is empty."
	}
	set slot [::xoXSD::Generator::Virtual::xoSlot new $name $type $xmltype]
	[my parent] addSlot $slot
	return $slot
}
	
Container instproc addSlot {slot} {
	[my xoclass] addSlot $slot
}






schema instproc init args {
	my xoClasses [list]
	my simpleTypes [list]
	next
}
	
schema instproc realInit args {
	set children [my getAllChildren]
	foreach child $children {
		$child earlyInit
	}
	foreach child $children {
		$child realInit
	}
}
	
schema instproc addClass {c} {
	my lappend xoClasses $c
}	
	
schema instproc getClasses {{dummy false}} {
	set o "namespace eval [my getNamespace] \{\n\n"
	append o "variable xmlNamespace \"[my xoTargetNamespace]\"\n"
	append o "variable xmlPrefix \"[my xoTargetPrefix]\"\n\n"
	foreach c [lsort [my xoClasses]] {
		if { $dummy } {
			append o "Class [$c name]\n"
		} else {
			append o [$c asXOTcl]
		}	
	}
	return "$o\}\n"
}
	
schema instproc getNamespace {} {
	return "[my xoNamespacePrefix]\::[my xoTargetPrefix]"
}
	
schema instproc getDummyClasses {} {
	return [my getClasses true]
}
	
schema instproc addSimpleType {s} {
	my lappend simpleTypes $s
}	






element instproc realInit args {
	if { [[my node] hasAttribute name] } {
		my name [[my node] getAttribute name]
		set type [my getType [[my node] getAttribute type]]
		
		#check if we've got complexElement:
		if { [namespace qualifiers $type] != "::xoXSD::DataTypes" } {
			my xoClassCreate [my name] $type
		
		} else {
			#handle simple text-elements:
			set c [my xoClassCreate [my name] "::xoXSD::Core::xsd:element"]
			set slot [::xoXSD::Generator::Virtual::xoSlot new "__text" "XML:Attribute" $type]
			$slot addArg "-text true"
			$c addSlot $slot
		} 
		
	} elseif { [[my node] hasAttribute ref] } {
		set type [my getType [[my node] getAttribute ref]]
		my name [namespace tail $type]
		set slot [my parentAddSlot [my name] "XML:Element" $type]
		if { [[my node] hasAttribute minOccurs] } {
			$slot addArg "-minOccurs [[my node] getAttribute minOccurs]"
		}
		if { [[my node] hasAttribute maxOccurs] } {
			$slot addArg "-maxOccurs [[my node] getAttribute maxOccurs]"
		}
		
	} else {
		error "DON'T KNOW WHAT TO DO..."	
	}
}

element instproc getType {type} {
	set oldtype $type
	if { [my getXMLPrefix $type] != "" } {	
		set xoNamespacePrefix [[my root] xoNamespacePrefix]
		set prefix [my getXMLPrefix $type]
		set type [my getXMLName $type]
		return "$xoNamespacePrefix\::$prefix\::$type"
	} else {
		return "::xoXSD::DataTypes::$type"
	}
}




attribute instproc earlyInit args {
	if { [namespace tail [[my parent] class]] == "attributeGroup" } {
		my realInit $args
	}
}

attribute instproc realInit args {
	set xmlname [[my node] getAttribute name]
	set xmltype [[my node] getAttribute type]
	
	my name [my getXMLName $xmlname] 
	set type [my XMLNametoXOTclClass $xmltype] 
	
	#search for simpleType's restrictions (e.g. enumerations)
	set enumvalues ""
	foreach simpleType [[my root] simpleTypes] {
		#our attribute's type is a simpleType:
		if { [namespace tail $type] == [$simpleType name] } {
			#change attribute's type to simpleType's restriction base
			set type [$simpleType base]
			
			#"extract" the enumeration's values
			set enumvalues "-enumvalues \{ "
			foreach value [$simpleType enumvalues] {
				append enumvalues "\"$value\" "
			}
			append enumvalues "\}"
			
		}
	}
	
	#finally create the slot
	set slot [my parentAddSlot [my name] "XML:Attribute" $type]
	
	#search for "use" - attribute
	if { [[my node] hasAttribute use] } {
		$slot addArg "-use [[my node] getAttribute use]"
	}
	
	#add the "-enumvalues" slot
	if { $enumvalues != "" } {
		$slot addArg $enumvalues
	}
	
	
}



	
	

sequence instproc realInit args {
	my setNameByPrefix "[[my parent] name]\::__sequence"
	set type "::xoXSD::Core::xsd:sequence"
	my xoClassCreate [my name] $type
	my parentAddSlot [namespace tail [my name]] "XML:Child"
}

sequence instproc addSlot {slot} {
	$slot addArg "-sequence [my counter]"
	my counter [expr {[my counter] + 10}]
	next
}

	
	



choice instproc realInit args {		
	my setNameByPrefix "[[my parent] name]\::__choice"
	set type "::xoXSD::Core::xsd:choice"
	my xoClassCreate [my name] $type
	my parentAddSlot [namespace tail [my name]] "XML:Child"
}






complexType instproc realInit args {
	set type "::xoXSD::Core::xsd:complexType"		

	if { [[my node] hasAttribute name] } {
		set xmlname [[my node] getAttribute name]
		my name [my getXMLName $xmlname]
		
	} else {
		error "ANONYMOUS complexType..."
	}

	my xoClassCreate [my name] $type
	
	foreach child [my info children] {
		set name [[$child node] nodeName]
		if { $name != "complexContent" && $name != "simpleContent" } {
			#
			# FIXME!!!
			#
			#puts "#Ignoring1 [my name]'s child: $name"
			continue
		}
		#search for <restriction> or <extension>:
		foreach grandchild [$child info children] {
			set n [[$grandchild node] nodeName]
			
			if { $n == "extension" && $name == "complexContent"} {
				#puts "FOUND EXTENSION..."
				set base [[$grandchild node] getAttribute base]
				set xmlbase [my getXMLName $base]
				[my xoclass] type [my XMLNametoXOTclClass $xmlbase]
				
			} elseif { $n == "restriction" && $name == "complexContent" } {
				#puts "FOUND RESTRICTION..."
				my children [concat \
					[my children] \
					[$grandchild children] \
				]
				
			} elseif { $n == "extension" && $name == "simpleContent" } {
				set base [[$grandchild node] getAttribute base]
				set xmlbase [my getXMLName $base]
				set type [my XMLNametoXOTclClass $xmlbase]
				set slot [::xoXSD::Generator::Virtual::xoSlot new "__text" "XML:Attribute" $type]
				$slot addArg "-text true"
				[my xoclass] addSlot $slot
				
			} else {
				puts "#HUH? -> $n --> $name"
			}
			
			#adjust the "parent"-slot...
			foreach grandgrandchild [$grandchild children] {
				$grandgrandchild parent [self]
			}
		}
	}
}






simpleType instproc earlyInit args {
	if { [[my node] hasAttribute name] } {
		set name [[my node] getAttribute name]
		my name [my getXMLName $name]
		foreach child [my info children] {
			set childclass [namespace tail [$child class]]
			if { $childclass == "restriction" } {
				set xmltype [[$child node] getAttribute base]
				my base [my XMLNametoXOTclClass $xmltype]
				my enumvalues [list]
				foreach grandchild [$child info children] {
					set grandchildclass [namespace tail [$grandchild class]]
					if { $grandchildclass == "enumeration" } {
						my lappend enumvalues [[$grandchild node] getAttribute value]
					} else {
						puts "#IGNORING $name's grandchild: $grandchildclass"
					}
				}
			} else {
				puts "#IGNORING $name's child: $childclass"
			}
		}
		[my root] addSimpleType [self]
		
	} else {
		puts "#EARLY -> ignored [self] [[self] class]"
	}
}





attributeGroup instproc earlyInit args {
	if { [[my node] hasAttribute name] } {
		set name [[my node] getAttribute name]
		my name [my getXMLName $name]
		my xoClassCreate [my name] "xoXSD::Core::xsd:attributeGroup"
		
	} else {
		puts "#EARLY -> ignored [self] [[self] class]"
	}
}


attributeGroup instproc realInit args {	
	if { [[my node] hasAttribute ref] } {
		set ref [[my node] getAttribute ref]
		my name [my getXMLName $ref]
		
		set cls ""
		foreach c [[my root] xoClasses] {
			if { [$c name] == [my name] } {
				set cls $c
				break
			}
		}
		if { $cls == "" } {
			error "attributeGroup -> didn't find class."
		}
		
		foreach slot [$cls getSlots] {
			[[my parent] xoclass] addSlot $slot
		}
		
	} else {
		puts "#LATE -> ingored [self] [[self] class]"	
	}
}
	
}

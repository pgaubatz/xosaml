package provide xoXSD::Generator::Parser 0.1

package require tdom
package require XOTcl
package require xoXSD::Generator::Virtual
package require xoXSD::DataTypes

namespace eval ::xoXSD::Generator::Parser {

proc parse {document targetprefix targetnamespace {prefix ""}} {
	set parser [::xoXSD::Generator::Parser::schema new $document]
	$parser xoTargetPrefix $targetprefix
	$parser xoNamespacePrefix $prefix
	$parser xoTargetNamespace $targetnamespace
	$parser realInit
	return $parser
}

::xotcl::Class Container -slots {
	::xotcl::Attribute node
	::xotcl::Attribute parent
	::xotcl::Attribute children
	::xotcl::Attribute root
	::xotcl::Attribute name -default ""
	::xotcl::Attribute xoclass
}
	
::xotcl::Class schema		-superclass Container -slots {
	::xotcl::Attribute xoClasses
	::xotcl::Attribute xoNamespacePrefix -default ""
	::xotcl::Attribute xoTargetPrefix
	::xotcl::Attribute xoTargetNamespace
	::xotcl::Attribute simpleTypes
	::xotcl::Attribute complexTypes
	::xotcl::Attribute elements
	::xotcl::Attribute attributeGroups
	::xotcl::Attribute sequences
}
	
::xotcl::Class element		-superclass Container
::xotcl::Class attribute	-superclass Container 
::xotcl::Class complexType	-superclass Container
::xotcl::Class sequence		-superclass Container -slots {
	::xotcl::Attribute isSorted -default false
}
::xotcl::Class extension	-superclass Container
::xotcl::Class complexContent	-superclass Container
::xotcl::Class choice		-superclass Container
::xotcl::Class enumeration	-superclass Container
::xotcl::Class any		-superclass Container
::xotcl::Class restriction	-superclass Container
::xotcl::Class import		-superclass Container
::xotcl::Class attributeGroup	-superclass Container -slots {
	::xotcl::Attribute attributes
}
::xotcl::Class simpleType	-superclass Container -slots {
	::xotcl::Attribute base
	::xotcl::Attribute enumvalues -default false
}
::xotcl::Class simpleContent	-superclass Container
::xotcl::Class anyAttribute	-superclass Container




Container instproc init {node {parent ""} {root ""}} {
	my node $node
	my parent $parent
	my root $root
	if { $root == "" } {
		my root [self]	
	}
	
	#puts "INIT -> [$node nodeName] SELF=[self] PARENT=[my parent] ROOT=[my root]"
	
	foreach node [[my node] childNodes] {
		set type [$node nodeName]
		
		if { $type == "annotation" } continue
		if { $type == "documentation" } continue
		if { $type == "#text" } continue
		if { $type == "#comment" } continue
		
		eval ::xoXSD::Generator::Parser::$type new -childof [self] $node [self] [my root]
	}
	
	my children [my info children]
}
	
Container instproc getXMLName {xmlname} {
	if { [string first : $xmlname] != -1 } {
		set tmp [split $xmlname ":"]
		return [lindex $tmp 1]
	}
	return $xmlname
}

Container instproc getXMLPrefix {xmlname} {
	if { [string first : $xmlname] != -1 } {
		set tmp [split $xmlname :]
		return [lindex $tmp 0]
	}
	return ""
}

Container instproc XMLNametoXOTclClass {xmlname} {
	set xoNamespacePrefix [[my root] xoNamespacePrefix]
	set xoTargetPrefix [[my root] xoTargetPrefix]
	
	set name [my getXMLName $xmlname]
	
	if { [my getXMLPrefix $xmlname] != "" } {	
		set prefix [my getXMLPrefix $xmlname]
	} else {
		set prefix "::xoXSD::DataTypes"
		if { ![Object isobject "$prefix\::$name"] } {
			set prefix "$xoNamespacePrefix\::$xoTargetPrefix"
		}
	}
	
	return "$prefix\::$name"
}

Container instproc getAllChildren {} {
	set children [list]
	foreach child [my info children] {
		lappend children $child	
	}
	foreach child $children {
		set children [concat $children [$child getAllChildren]] 
	}
	return $children
}

Container instproc realInit args {}

Container instproc earlyInit args {}

Container instproc setNameByPrefix {prefix} {
	set complexTypes [[my root] complexTypes]
	set i 0
	while { [lsearch [lsort $complexTypes] "*\::$prefix$i"] != -1 } { incr i }
	my name "$prefix$i"
}
	
Container instproc parentAddSlot {name type {xmltype ""}} {
	if { $name == "" || $type == "" } {
		error "parentAddSlot: name and/or type is empty."
	}
	set slot [::xoXSD::Generator::Virtual::xoSlot new $name $type $xmltype]
	[my parent] addSlot $slot
	return $slot
}
	
Container instproc addSlot {slot} {
	[my xoclass] addSlot $slot
}






schema instproc init args {
	my xoClasses [list]
	my simpleTypes [list]
	my complexTypes [list]
	my elements [list]
	my attributeGroups [list]
	next
}
	
schema instproc realInit args {
	set children [my getAllChildren]
	foreach child $children {
		$child earlyInit
	}
	foreach child $children {
		$child realInit
	}
}

proc lmove {varName index newIndex} {
	upvar $varName var
	set value [lindex $var $index]
	for {set i $index} {$i > $newIndex} {incr i -1} {
		lset var $i [lindex $var [expr $i - 1]]
	}
	lset var $newIndex $value
}

schema instproc getClasses {{dummy false}} {
	#first sort the complexTypes to resolve interdependencies
	set complexTypes [lsort [my complexTypes]]
	while true {
		set quit true
		for {set i 0} {$i < [llength $complexTypes]} {incr i} {
			set c [lindex $complexTypes $i]
			if { [namespace qualifiers [$c type]] == "::xoXSD::Core" } {
				continue
			}
			
			#get the index of the dependent class
			set dep [lsearch -glob $complexTypes *::[namespace tail [$c type]]]
			
			#skip this, because the dependent class has already been defined
			if { $i > $dep } {
				continue
			}
			
			set quit false
			lmove complexTypes $dep $i
			break
		}
		if { $quit } {
			my complexTypes $complexTypes
			
			#quit the endless-loop
			break
		}
	}
	
	#sort the sequence's children
	foreach sequence [my sequences] {
		$sequence sortChildren
	}
	
	set o "namespace eval [my getNamespace] \{\n\n"
	append o "variable xmlNamespace \"[my xoTargetNamespace]\"\n"
	append o "variable xmlPrefix \"[my xoTargetPrefix]\"\n"
	append o "\n#\n# ComplexTypes:\n#\n"
	foreach c [my complexTypes] {
		if { $dummy } {
			append o "Class [$c name]\n"
		} else {
			append o [$c asXOTcl]
		}	
	}
	append o "\n#\n# Elements:\n#\n"
	foreach c [lsort [my elements]] {
		if { $dummy } {
			append o "Class [$c name]\n"
		} else {
			append o [$c asXOTcl]
		}	
	}
	return "$o\}\n"
}
	
schema instproc getDummyClasses {} {
	return [my getClasses true]
}	
	
schema instproc getNamespace {} {
	return "[my xoNamespacePrefix]\::[my xoTargetPrefix]"
}
	
schema instproc addSimpleType {s} {
	my lappend simpleTypes $s
}
	
schema instproc addComplexType {c} {
	my lappend complexTypes $c
}
	
schema instproc addElement {e} {
	my lappend elements $e
}
	
schema instproc addAttributeGroup {a} {
	my lappend attributeGroups $a
}

schema instproc addSequence {s} {
	my lappend sequences $s
}





element instproc realInit args {
	if { [[my node] hasAttribute name] && [[my node] hasAttribute type]} {
		my name [[my node] getAttribute name]
		set type [my getType [[my node] getAttribute type]]
		
		#search for simpleTypes:
		foreach simpleType [[my root] simpleTypes] {
			#our attribute's type is a simpleType:
			if { [namespace tail $type] == [$simpleType name] } {
				#change element's type to simpleType's restriction base
				set type [$simpleType base]
			}
		}
		
		#check if we've got complexElement:
		if { [namespace qualifiers $type] != "::xoXSD::DataTypes" } {
			my xoclass [::xoXSD::Generator::Virtual::xoClass [my name] [my name] $type]
			[my root] addElement [my xoclass]
		
		} else {
			#handle simple text-elements:
			set slot [::xoXSD::Generator::Virtual::xoSlot new "__text" "XML:Attribute" $type]
			$slot addArg "-text true"
			my xoclass [::xoXSD::Generator::Virtual::xoClass [my name] [my name] "::xoXSD::Core::Element"]
			[my xoclass] addSlot $slot
			[my root] addElement [my xoclass]
		} 
	
	} elseif { [[my node] hasAttribute name] } {
		#just set the name, everthing else is done within the 
		#enclosed <complexContent> or <simpleContent>.
		my name [[my node] getAttribute name]
		
	} elseif { [[my node] hasAttribute ref] } {
		set type [my getType [[my node] getAttribute ref]]
		my name [namespace tail $type]
		set slot [my parentAddSlot [my name] "XML:Element" $type]
		if { [[my node] hasAttribute minOccurs] } {
			$slot addArg "-minOccurs [[my node] getAttribute minOccurs]"
		}
		if { [[my node] hasAttribute maxOccurs] } {
			set maxOccurs [[my node] getAttribute maxOccurs]
			set arg "-maxOccurs $maxOccurs"
			if { $maxOccurs == "unbounded" || $maxOccurs > 1 } {
				append arg " -multivalued true"
			}
			$slot addArg $arg
		}
		
	} else {
		error "DON'T KNOW WHAT TO DO..."	
	}
}

element instproc getType {type} {
	set oldtype $type
	if { [my getXMLPrefix $type] != "" } {	
		set xoNamespacePrefix [[my root] xoNamespacePrefix]
		set prefix [my getXMLPrefix $type]
		set type [my getXMLName $type]
		return "$xoNamespacePrefix\::$prefix\::$type"
	} else {
		return "::xoXSD::DataTypes::$type"
	}
}




attribute instproc earlyInit args {
	if { [namespace tail [[my parent] class]] == "attributeGroup" } {
		my realInit $args
	}
}

attribute instproc realInit args {
	set xmlname [[my node] getAttribute name]
	set xmltype [[my node] getAttribute type]
	
	my name [my getXMLName $xmlname] 
	set type [my XMLNametoXOTclClass $xmltype] 
	
	#search for simpleType's restrictions (e.g. enumerations)
	set enumvalues ""
	foreach simpleType [[my root] simpleTypes] {
		#our attribute's type is a simpleType:
		if { [namespace tail $type] == [$simpleType name] } {
			#change attribute's type to simpleType's restriction base
			set type [$simpleType base]
			
			#"extract" the enumeration's values
			set enumvalues "-enumvalues \{ "
			foreach value [$simpleType enumvalues] {
				append enumvalues "\"$value\" "
			}
			append enumvalues "\}"
			
		}
	}
	
	#finally create the slot
	if { [namespace tail [[my parent] class]] == "attributeGroup" } {
		set slot [::xoXSD::Generator::Virtual::xoSlot new [my name] "XML:Attribute" $type]
		[my parent] addAttribute $slot
	} else {
		set slot [my parentAddSlot [my name] "XML:Attribute" $type]
	}
	
	#search for "use" - attribute
	if { [[my node] hasAttribute use] } {
		$slot addArg "-use [[my node] getAttribute use]"
	}
	
	#add the "-enumvalues" slot
	if { $enumvalues != "" } {
		$slot addArg $enumvalues
	}
	
	
}






anyAttribute instproc realInit args {
	set slot [my parentAddSlot "__anyAttribute" "XML:Attribute"]
	$slot addArg "-any true"
	if { [[my node] hasAttribute namespace] } {
		$slot addArg "-namespace \"[[my node] getAttribute namespace]\""
	}
}	






any instproc realInit args {
	set slot [my parentAddSlot "__any" "XML:Element"]
	$slot addArg "-any true"
	if { [[my node] hasAttribute minOccurs] } {
		$slot addArg "-minOccurs [[my node] getAttribute minOccurs]"
	}
	if { [[my node] hasAttribute maxOccurs] } {
		$slot addArg "-maxOccurs [[my node] getAttribute maxOccurs]"
	}
	if { [[my node] hasAttribute namespace] } {
		$slot addArg "-namespace \"[[my node] getAttribute namespace]\""
	}
}





sequence instproc realInit args {
	my setNameByPrefix "[[my parent] name]\::__sequence"
	set type "::xoXSD::Core::Sequence"
	my xoclass [::xoXSD::Generator::Virtual::xoClass [my name] [my name] $type]
	[my root] addComplexType [my xoclass]
	[my root] addSequence [self]
	my parentAddSlot [namespace tail [my name]] "XML:Child"
}

sequence instproc sortChildren {} {
	if { [my isSorted] } {
		return
	}
	set children [my info children]
	set slots [[my xoclass] getSlots]
	set i 0
	foreach node [[my node] childNodes] {
		foreach child $children {
			if { $node != [$child node] } {
				continue
			}
			foreach slot $slots {
				set name [namespace tail [$child name]]
				if { [$slot name] != $name } {
					continue
				}
				if { [string first "-sequence" [$slot asXOTcl]] != -1 } {
					continue
				}
				$slot addArg "-sequence [incr i]"
			}
		}
	}
	my isSorted true
}


	
	



choice instproc realInit args {		
	my setNameByPrefix "[[my parent] name]\::__choice"
	set type "::xoXSD::Core::Choice"
	my xoclass [::xoXSD::Generator::Virtual::xoClass [my name] [my name] $type]
	[my root] addComplexType [my xoclass]
	my parentAddSlot [namespace tail [my name]] "XML:Child"
}






complexType instproc realInit args {
	set type "::xoXSD::Core::ComplexType"		

	if { [[my node] hasAttribute name] } {
		set xmlname [[my node] getAttribute name]	
	} else {
		#we've got an anonymous <complexType>, enclosed by an <element>:
		set xmlname [[[my parent] node] getAttribute name]
	}
	
	my name [my getXMLName $xmlname]
	my xoclass [::xoXSD::Generator::Virtual::xoClass [my name] [my name] $type]
	[my root] addComplexType [my xoclass]
	
	foreach child [my info children] {
		set name [[$child node] nodeName]
		if { $name != "complexContent" && $name != "simpleContent" } {
			#
			# FIXME!!!
			#
			#puts "#Ignoring1 [my name]'s child: $name"
			continue
		}
		#search for <restriction> or <extension>:
		foreach grandchild [$child info children] {
			set n [[$grandchild node] nodeName]
			
			if { $n == "extension" && $name == "complexContent"} {
				#puts "FOUND EXTENSION..."
				set base [[$grandchild node] getAttribute base]
				set xmlbase [my getXMLName $base]
				[my xoclass] type [my XMLNametoXOTclClass $xmlbase]
				
			} elseif { $n == "restriction" && $name == "complexContent" } {
				#puts "FOUND RESTRICTION..."
				my children [concat \
					[my children] \
					[$grandchild children] \
				]
				
			} elseif { $n == "extension" && $name == "simpleContent" } {
				set base [[$grandchild node] getAttribute base]
				set xmlbase [my getXMLName $base]
				set type [my XMLNametoXOTclClass $xmlbase]
				set slot [::xoXSD::Generator::Virtual::xoSlot new "__text" "XML:Attribute" $type]
				$slot addArg "-text true"
				[my xoclass] addSlot $slot
				
			} else {
				puts "#HUH? -> $n --> $name"
			}
			
			#adjust the "parent"-slot...
			foreach grandgrandchild [$grandchild children] {
				$grandgrandchild parent [self]
			}
		}
	}
}






simpleType instproc earlyInit args {
	if { [[my node] hasAttribute name] } {
		set name [[my node] getAttribute name]
		my name [my getXMLName $name]
		foreach child [my info children] {
			set childclass [namespace tail [$child class]]
			if { $childclass == "restriction" } {
				set xmltype [[$child node] getAttribute base]
				my base [my XMLNametoXOTclClass $xmltype]
				my enumvalues [list]
				foreach grandchild [$child info children] {
					set grandchildclass [namespace tail [$grandchild class]]
					if { $grandchildclass == "enumeration" } {
						my lappend enumvalues [[$grandchild node] getAttribute value]
					} else {
						puts "#IGNORING $name's grandchild: $grandchildclass"
					}
				}
			} else {
				puts "#IGNORING $name's child: $childclass"
			}
		}
		[my root] addSimpleType [self]
		
	} else {
		puts "#EARLY -> ignored [self] [[self] class]"
	}
}





attributeGroup instproc earlyInit args {
	if { [[my node] hasAttribute name] } {
		set name [[my node] getAttribute name]
		my name [my getXMLName $name]
		my attributes [list]
		[my root] addAttributeGroup [self]
	}
}

attributeGroup instproc realInit args {	
	if { [[my node] hasAttribute ref] } {
		set ref [[my node] getAttribute ref]
		my name [my getXMLName $ref]
		
		set cls ""
		foreach c [[my root] attributeGroups] {
			if { [$c name] == [my name] } {
				set cls $c
				break
			}
		}
		if { $cls == "" } {
			error "attributeGroup -> didn't find class."
		} 
		
		foreach attr [$cls attributes] {
			[[my parent] xoclass] addSlot $attr
		}
	}
}
	
attributeGroup instproc addAttribute {attr} {
	my lappend attributes $attr
}
	
}

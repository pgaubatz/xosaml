package provide xoXSD::Core 0.1

package require tdom
package require xoXSD::DataTypes

namespace eval ::xoXSD {
	
##############################################
#               * Definition *               #
##############################################	
	
::xotcl::Class XSDObject	-superclass ::xotcl::Class -slots {
	::xotcl::Attribute rootClass -default ""
	::xotcl::Attribute elements
	::xotcl::Attribute attributes
	::xotcl::Attribute childslots
	::xotcl::Attribute children
}
	
::xotcl::Class XSDChildObject	-superclass ::xoXSD::XSDObject

::xotcl::Class Element		-superclass ::xoXSD::XSDObject 

::xotcl::Class ComplexType	-superclass ::xoXSD::XSDObject

::xotcl::Class Sequence		-superclass ::xoXSD::XSDChildObject -slots {
	::xotcl::Attribute sequence -default false
}

::xotcl::Class Choice		-superclass ::xoXSD::XSDChildObject -slots {
	::xotcl::Attribute slotfree 	 -default true
	::xotcl::Attribute choiceparents -default ""
}
	
##############################################
#              * Constructors *              #
##############################################

XSDObject instproc init args {
	if { [my rootClass] eq "" } {
		my rootClass [my class]
	}
	
	set heritage [list]
	foreach c [[my class] info heritage] {
		if { [namespace qualifiers $c] eq "::xoXSD" } break
		lappend heritage $c
	}

	my children [list]
	my childslots [list]
	my elements [list]
	my attributes [list]
	
	# create new instances of all classchildren
	foreach c [concat [my class] [lreverse $heritage]] {
		foreach	child [$c info classchildren] {
			set ch [eval $child new -childof [self] -rootClass [my rootClass]]
			my [namespace tail [$ch class]] $ch
			my lappend children $ch
		}
	}
	
	foreach slot [my getLocalSlots] {
		set slotclass [namespace tail [$slot class]]
		
		if { $slotclass eq "XMLAttribute" } {
			my addAttribute $slot
		} elseif { $slotclass eq "XMLElement" } {
			my addElement $slot
		} elseif { $slotclass eq "XMLChild" } {
			my lappend childslots $slot
		}
	}
	
	# init text-only elements with the given string $args
	if { [llength $args] > 0 } {
		my trySetContent [join $args]
	}
}

Sequence instproc init args {
	# XSDObject->init
	next 
	
	set slots [list]
	foreach slot [my getLocalSlots] {
		if { [namespace tail [$slot class]] eq "XMLAttribute" } {
			continue
		}
		lappend slots [list $slot [$slot sequence]]
	}
	
	my sequence [list]
	foreach slot [lsort -integer -index 1 $slots] {
		set slot [lindex $slot 0]
		set slotname [namespace tail $slot]
		set slotclass [namespace tail [$slot class]]
		
		if { $slotclass eq "XMLChild" } {
			foreach child [my children] {
				set childclass [namespace tail [$child class]]
				if { $childclass eq $slotname } {
					my lappend sequence $child	
				}
			}
		} else {
			my lappend sequence $slot
		}
	}
	
	# add the missing childclasses (with no sequence)
	foreach child [my children] {
		if { [lsearch [my sequence] $child] == -1 } {
			my lappend sequence $child
		}
	}
}

Choice instproc init args {
	# XSDObject->init
	next 	
	
	# get "choice-parents"...
	set parent [my info parent]
	while { [Object isobject $parent] } {
		set cls [namespace tail [$parent class]]
		if { [string match "__choice*" $cls] } {
			my lappend choiceparents $parent	
		}
		set parent [$parent info parent]
	}
}


##############################################
# * Various "publicly" available functions * #
##############################################

XSDObject instproc check {} {	
	foreach slot [my attributes] {
		if { [$slot use] eq "required" && ![my slotFilled $slot] } {
			my error "needs object: [namespace tail $slot] (type: [$slot type])"
			return false
		}
	}
	foreach slot [my elements] {
		if { ![my checkMinOccurs $slot] } { 
			return false 
		}
	}
	foreach child [my getAllChildren] {
		if { ![$child check] } {
			return false
		}
	}
	
	return true
}
	
Choice instproc check {} {
	if { [my slotfree] } { 
		return true 
	}
	
	set choice ""
	foreach slot [my elements] {
		if { [my slotFilled $slot] } {
			set choice $slot
			break
		}
	}	
	if { $choice eq "" } { 
		return true 
	}
	if { ![my checkMinOccurs $choice] } {
		return false
	}
	foreach slot [my getSlot $choice] {
		if { ![$slot check] } {
			return false
		}
	}
	return true
}

XSDObject instproc marshal { -name {-addXmlNamespaces:boolean true} {-compact:boolean false} } {
	if { ![my check] } {
		my error "is not valid."
		return ""
	}
	
	# create the document:
	set doc [dom createDocument [my getXmlElementMarshalName]]
	set root [$doc documentElement]
	
	# add the xmlns-attributes:
	if { $addXmlNamespaces } {
		set prefix [my getXmlPrefix]	
		$root setAttribute "xmlns:$prefix" [my getXmlNamespace]
		my setXmlnsAttributes $root	
	}
	
	# add the attributes:
	my marshalAttributes $doc $root
	
	# add the containing sub-elements:
	my marshalElements $doc $root

	set xml [$root asXML]
	
	# prevent memory leaking:
	$doc delete
	
	# strip all whitespaces between elements:
	if { $compact } {
		regsub -all {>\s+<} $xml {><} xml
		regsub -all {\n}    $xml {}   xml
	}

	return $xml
}

XSDObject instproc print { {-compact:boolean false} } {
	puts "Marshalling [self] ([my class]) ..."
	puts [my marshal -compact $compact]
}

XSDObject instproc printContent {} {
	set content [my getContent]
	if { $content == false } {
		my error "doesn't have any textual content!"
		return
	}
	puts "The textual content of [self] ([my class]) is:\n$content"
}

XSDObject instproc getSlot {slot} {
	set s [my doGetSlot $slot]
	if { $s == false } {
		my error "there is no such Element/Attribute to be get: $slot"	
		return false
	} 
	return $s
}

XSDObject instproc getSlotClass { {-withChildSlots:boolean false} slot } {
	set slotclass [my doGetSlotClass -withChildSlots $withChildSlots $slot]
	if { $slot == false } {
		my error "there is no such slot: $slot"	
		return false
	} 
	return $slotclass
}

XSDObject instproc getContent {} {
	set content [my getSlot __text]
	if { $content == false } {
		return ""
	}
	return [$content getContent]
}

XSDObject instproc setSlot {slot value} {
	if { [my doSetSlot $slot $value] == true } {
		return true
	} else {
		my error "there is no such Element/Attribute to be set: $slot"	
		return false
	}
}

XSDObject instproc setContent {text} {
	if { [my trySetContent $text] } {
		return true
	}
	my error "there is no textual content to be set"
	return false
}
	
XSDObject instproc printSlots {} {
	# first get a list of all elements and attributes:
	set elements   [my elements]
	set attributes [my attributes]
	foreach child [my getAllChildren] {
		set elements   [concat $elements   [$child elements  ]]
		set attributes [concat $attributes [$child attributes]]
	}
	
	set classname [namespace tail [my class]]
	set headers [list "Name" "Type" "Additional Information"]
	
	if { [llength $elements] > 0 } {
		set content [list]
		foreach e $elements {
			lappend content [list [$e getName $e] [$e getType] [$e getInfo]]
		}
		puts [my makeTable "Elements of \"$classname\"" $headers $content]
	}
	if { [llength $attributes] > 0 } {
		set content [list]
		foreach a $attributes {
			lappend content [list [$a getName $a] [$a getType] [$a getInfo]]
		}
		puts [my makeTable "Attributes of \"$classname\"" $headers $content]
	}
}
	
XSDObject instproc addAny {slot} {
	set slot [my lookupObject $slot]
	set slotname [namespace tail [$slot class]]
	
	# first check if the element actually has an <any> element:
	set any [my getSlotClass __any]
	if { $any == false } {
		my error "there is no <any> element to be set."
		return false
	}
	
	# search for the class/instance that has the __any slot defined:
	set cls [[$any info parent] info parent]
	set inst ""
	foreach inst [concat [self] [my getAllChildren]] {
		set c [$inst class]
		if { $c eq $cls || [lsearch [$c info heritage] $cls] != -1 } { 
			break
		}
	}
	if { $inst eq "" } { error "should not reach here. didn't find inst!" }
	
	# check if a slot named $slotname already exists:
	if { [$inst slotExists $slotname] } {
		my error "there's is already a slot named \"$slotname\"."
		return false
	}
	
	# check for maxOccurs restrictions:
	set anyslot "$cls\::slot\::__any"
	set anyCounter [$anyslot anyCounter]
	set maxOccurs [$anyslot maxOccurs]
	if { $maxOccurs ne "unbounded" } {
		if { $anyCounter >= $maxOccurs } {
			my error "cannot be set because of a maxOccurs restriction."
			return false
		}
	}
	
	# check for namespace restrictions:
	set namespaces [split [$anyslot namespace] " "]
	if { ![my checkAnyNamespaceRestrictions $namespaces $inst $slot] } {
		my error "cannot be set because of namespace restrictions."
		return false
	}
	
	# dynamically create and add a new slot to the class
	$cls slots "::xoXSD::Slots::XMLElement $slotname -type [$slot class]"
	$inst addElement "$cls\::slot\::$slotname"
	
	# finally set the newly created slot
	my setSlot $slotname $slot
	
	# update the anyCounter if necessary
	if { $maxOccurs ne "unbounded" } {
		$anyslot anyCounter [incr anyCounter]
	}
}
	
XSDObject instproc addAnyAttribute {slotname type value} {
	# first check if the element actually has an <any> element:
	set anyAttribute [my getSlotClass __anyAttribute]
	if { $anyAttribute == false } {
		my error "there is no <anyAttribute> attribute to be set."
		return false
	}
	
	# search for the class/instance that has the __anyAttribute slot defined:
	set cls [[$anyAttribute info parent] info parent]
	set inst ""
	foreach inst [concat [self] [my getAllChildren]] {
		set c [$inst class]
		if { $c eq $cls || [lsearch [$c info heritage] $cls] != -1 } { 
			break
		}
	}
	if { $inst eq "" } { error "should not reach here. didn't find inst!" }
	
	# check for namespace restrictions:
	set anyslot "$cls\::slot\::__anyAttribute"
	set namespaces [split [$anyslot namespace] " "]
	set content [$type new $value]
	if { ![my checkAnyNamespaceRestrictions $namespaces $inst $content] } {
		my error "cannot be set because of namespace restrictions."
		return false
	}
	
	# dynamically create and add a new slot to the class
	$cls slots "::xoXSD::Slots::XMLAttribute $slotname -type $type"
	$inst addAttribute "$cls\::slot\::$slotname"
	
	# finally set the newly created slot
	my setSlot $slotname $content
}

##############################################
#         * Various helper functions *       #
# Note: you shouldn't call them directly.    #
##############################################

XSDObject instproc marshalAttributes {doc root} {
	# iterate over all attributes
	foreach attribute [my attributes] {
		my marshalAttribute $doc $root $attribute
	}
	
	# do the same with all children
	foreach child [my children] {
		$child marshalAttributes $doc $root	
	}
}

XSDObject instproc marshalAttribute {doc root attribute} {
	if { ![my slotFilled $attribute] } return
	
	set content [[my [namespace tail $attribute]] getContent]
	if { [$attribute text] } {
		$root appendChild [$doc createTextNode $content]
	} else {	
		$root setAttribute [namespace tail $attribute] $content
	}
}

XSDObject instproc marshalElements {doc root} {
	# iterate over all elements
	foreach element [my elements] {
		my marshalElement $doc $root $element
	}
	
	# do the same with all children
	foreach child [my children] {
		$child marshalElements $doc $root	
	}
}

Sequence instproc marshalElements {doc root} {
	foreach obj [my sequence] {
		if { [string match "*::slot::*" $obj ] } {
			my marshalElement $doc $root $obj
		} else {
			$obj marshalElements $doc $root	
		}
	}
}

XSDObject instproc marshalElement {doc root element} {
	if { ![my slotFilled $element] } return
	set name [my getXmlElementMarshalName $element] 
	foreach element [my [namespace tail $element]] {
		$root appendXML [$element marshal -addXmlNamespaces false -name $name]
	}
}

XSDObject instproc setXmlnsAttributes {root} {
	foreach element [my elements] {
		set element [namespace tail $element]
		if { ![my slotFilled $element] } continue
		
		set element [lindex [my $element] 0]
		set ns [$element getXmlNamespace]
		set prefix [$element getXmlPrefix]
		
		$root setAttribute "xmlns:$prefix" $ns
	}	
	foreach child [my children] {
		$child setXmlnsAttributes $root
	}
}
	
XSDObject instproc getXmlElementMarshalName { {element ""} } {
	if { $element eq "" } { 
		set element [my class] 
	}
	set name [namespace tail $element]
	set prefix [my getXmlPrefix]
	if { $prefix ne "" } {
		set name "$prefix:$name"
	}	
	return $name
}

XSDObject instproc getRootNamespaceVariable {varname} {
	set qualifiers [namespace qualifiers [my rootClass]]
	if { [namespace eval $qualifiers info exists $varname] } {
		namespace upvar $qualifiers $varname var
		return $var
	}
	return ""
}

XSDObject instproc getXmlNamespace {} {
	return [my getRootNamespaceVariable xmlNamespace]
}

XSDObject instproc getXmlPrefix {} {
	return [my getRootNamespaceVariable xmlPrefix]
}

XSDObject instproc getSlots { {-withChildSlots:boolean false} } {
	if { $withChildSlots } {
		return [concat [my elements] [my attributes] [my childslots]]
	} 
	return [concat [my elements] [my attributes]]
}

XSDObject instproc getLocalSlots {} {
	# now create a list of all slots
	set slots [[my class] info slots]
	
	# remember slotnames
	foreach slot $slots {set slotname([namespace tail $slot]) 1}
	
	# iterate over class structure
	set heritage [[my class] info heritage]
	foreach c [lsearch -inline -all -not $heritage "::xoXSD::*"] {
		foreach slot [$c info slots] {
			set key slotname([namespace tail $slot])
			
			# don't add slots which are already defined in 
			# more specialized classes
			if {[info exists $key]} continue
			set $key 1
			lappend slots $slot
		}
	}
	
	return $slots
}

XSDObject instproc getSlotType {slot} {
	# returns either XMLAttribute, XMLElement, XMLChild or false
	set slotclass [my getSlotClass $slot]
	if { $slotclass == false } { return false }
	return [namespace tail [$slotclass class]]
}

XSDObject instproc doGetSlot {slot} {
	set slot [namespace tail $slot]
	
	if { ![my slotExists $slot] || ![my exists [namespace tail $slot]] } {
		foreach child [my children] {
			set ret [$child doGetSlot $slot]
			if { $ret != false } { return $ret }
		}
		# there is no such slot:
		return false
		
	}
	
	set parent [my info parent]
	if { [Object isobject $parent] && [$parent class] ne "::xoXSD::CodeGenerator"} {
		set classname [namespace tail [my class]]
		set c [$parent getSlotClass -withChildSlots true $classname]
	
		if { [$c multivalued] } {
			set slots [list]
			foreach child [$parent $classname] {
				if { [$child exists $slot] } {
					lappend slots [$child $slot]
				}
			}
			if { [llength $slots] == 0 } {
				return false
			}
			return $slots
		}
	}
	
	return [my $slot]
}

XSDObject instproc doSetSlot {slot value} {
	set slot [namespace tail $slot]
	if { ![my slotExists $slot] } {
		if { [my children] eq "" } { return -1 }
		foreach child [my children] {
			set result [$child doSetSlot $slot $value]
			if { $result != -1 } { return $result } 		
		}
		return -1
	} 
	
	set c [my getSlotClass $slot]
	
	#Check if the given value-object matches the required type
	if { [$c type] ne [$value class] } {
		if { [$c type] ne [[$value class] info superclass] } {
			my error "\"$slot\" has to be of type [$c type]"
			return false
		}
	}
	
	#Check for a simpleType's enumeration restriction
	set enum [list]
	if { [$c exists enumvalues] } {
		set enum [$c enumvalues]
	}
	if { [llength $enum] > 0 } {
		if { [lsearch -exact $enum [$value getContent]] == -1 } {
			my error "\"$slot\" is not correctly formatted."
			return false
		}
	}
	
	#finally set slot
	if { [$c multivalued] && [my slotFilled $slot] } {
		set occurs [llength [my $slot]]
		set maxOccurs [$c maxOccurs]
		if { $maxOccurs eq "unbounded" || $occurs < $maxOccurs } {
			my $slot add $value
		} else {
			my error "\"$slot\" cannot be set because of a maxOccurs restriction."
			return false
		}
	} else {
		my $slot $value
	}
	return true
	
}

Choice instproc doSetSlot {slot value} {
	if { [my slotfree] } {
		if { [next] == true } {
			my slotfree false
			foreach parent [my choiceparents] {
				$parent slotfree false	
			}
			return true
		} else {
			return -1
		}
	} elseif { ![my slotfree] && [my slotExists $slot] } {
		set ret [my tryCreateChild $slot $value]
		if { $ret != -1 } {
			return $ret
		}
			
		if { [my children] eq "" } { return -1 }
		foreach child [my children] {
			set result [$child doSetSlot $slot $value]
			if { $result != -1 } { return $result }
		}
		error "Shouldn't reach here!"
	} else {
		my error "is already set by another Element/Attribute."
		return false
	}
}
	
Sequence instproc doSetSlot {slot value} {
	set ret [next]
	if { $ret != -1 } {
		return $ret
	}
	return [my tryCreateChild $slot $value]
}	
	
XSDChildObject instproc tryCreateChild {slot value} {
	set name [namespace tail [my class]]
	set parent [my info parent]
	set c [$parent getSlotClass -withChildSlots true $name]
	
	if { ![$c multivalued] } {
		return -1
	} 
	
	set occurs [llength [$parent $name]]
	set maxOccurs [$c maxOccurs]
	if { $maxOccurs eq "unbounded" || $occurs < $maxOccurs } {
		set ch [eval [my class] new -childof $parent [my rootClass]]
		
		$parent $name add $ch
		$parent addChild $ch
		
		return [$ch doSetSlot $slot $value]
	} 

	return -1
}

XSDObject instproc doGetSlotClass { {-withChildSlots:boolean false} slot } {
	set slot [namespace tail $slot]
	if { ![my slotExists -withChildSlots $withChildSlots $slot] } {
		foreach child [my children] {
			set result [$child doGetSlotClass $slot]
			if { $result != false } { return $result }
		}
		return false
		
	} else {
		return [lsearch -inline -glob [my getSlots -withChildSlots $withChildSlots] "*::$slot"]
	}
}

XSDObject instproc error {msg} {
	puts "XML-Error: [self] (type: [my class]) $msg"
}

XSDObject instproc slotExists { {-withChildSlots:boolean false} slot } {
	set existance [lsearch [my getSlots -withChildSlots $withChildSlots] "*::slot::[namespace tail $slot]"]
	return [expr { $existance != -1 } ]
}

XSDObject instproc slotFilled {slot} {
	return [my exists [namespace tail $slot]]
}

XSDObject instproc getAllChildren {} {
	set children [my children]
	foreach child [my children] {
		set children [concat $children [$child getAllChildren]]
	}
	return $children
}
	
XSDObject instproc addElement {element} {
	my lappend elements $element
}
		
Sequence instproc addElement {element} {
	next
	my lappend sequence $element
}	
	
XSDObject instproc addAttribute {attribute} {
	my lappend attributes $attribute
}

XSDObject instproc addChild {child} {
	my lappend children $child
}

Sequence instproc addChild {child} {
	next
	my lappend sequence $child
}
	
XSDObject instproc checkAnyNamespaceRestrictions {namespaces inst value} {	
	if { [lsearch $namespaces "##any"] != -1 } {
		return true
		
	} elseif { [lsearch $namespaces "##other"] != -1 } {
		if { [$value getXmlNamespace] ne [$inst getXmlNamespace] } {
			return true
		} 
		
	} elseif { [lsearch $namespaces "##targetNamespace"] != -1 } {
		if { [$value getXmlNamespace] eq [$inst getXmlNamespace] } {
			return true
		} 
		
	} elseif { [lsearch $namespaces "##local"] != -1 } {
		if { [$value getXmlNamespace] eq "" } {
			return true
		} 
		
	} else {
		foreach ns $namespaces {
			if { $ns eq [$value getXmlNamespace] } {
				return true
			}
		}
	}
	
	return false
}

XSDObject instproc checkMinOccurs {slot} {
	set name [namespace tail $slot]
	set validity true
	if { [$slot minOccurs] > 0 } {
		if { ![my slotFilled $slot] } {
			set validity false
			my error "needs object: $name (type: [$slot type])"
			
		} elseif { [llength [my $name]] < [$slot minOccurs] } {
			set validity false
			my error "needs [$slot minOccurs] instances of $name (type: [$slot type])"
		}	
	}	
	return $validity
}

XSDObject instproc makeTable {tableheader headers content} {
	set width [list]
	foreach header $headers {
		lappend width [string length $header]
	}
	foreach line $content {
		for {set i 0} {$i < [llength $line]} {incr i} {
			set colMax 0
			foreach colLine [lindex $line $i] {
				set colMax [expr max($colMax, [string length $colLine])]	
			}
			lset width $i [expr max($colMax, [lindex $width $i])]
		}
	}
	
	set sep "+"
	set lw 0
	foreach w $width {
		incr lw $w
		append sep "-[string repeat - $w]-+"
	}
	set o "+[string repeat - [expr $lw + 3 * [llength $headers] - 1]]+\n"
	append o "| [format "%-*s | " [expr $lw + 2 * [llength $headers]] $tableheader]\n"
	
	append o "$sep\n[my makeTableRow $width $headers]$sep\n"
	foreach line $content {
		set colLinesMax 1
		foreach colLines $line {
			set colLinesMax [expr max($colLinesMax, [llength $colLines])]
		}
		set content [list]
		for {set i 0} {$i < $colLinesMax} {incr i} {
			set content [list]
			for {set j 0} {$j < [llength $line]} {incr j} {
				lappend content [lindex [lindex $line $j] $i]
			}
			append o [my makeTableRow $width $content]
		}
		append o "$sep\n"
	}
	return $o
}

XSDObject instproc makeTableRow {width content} {
	set line "| "
	for {set i 0} {$i < [llength $content]} {incr i} {
		append line [format "%-*s | " [lindex $width $i] [lindex $content $i]]
	}
	return "$line\n"
}

XSDObject instproc unknown {cmd args} {
	set args [join $args]
	
	#read slot
	if { $args eq "" } {
		return [my getSlot $cmd]	
	}
	
	#set slot...
	return [my setSlot $cmd [my lookupObject $args]]
}

XSDObject instforward export %self marshal

XSDObject instproc . args {
	set args [split $args [list "." " "]]
	# remove empty list elements:
	set args [lsearch -all -inline -not -exact $args ""]
	set cmd "\[my [lindex $args 0]\]"
	foreach arg [lrange $args 1 end-1] {
		set cmd "\[$cmd $arg\]"
	}
	eval "$cmd [lindex $args end]"
}

XSDObject instproc createObject {type {args {}}} {
	set ns [uplevel 2 namespace current]
	set obj [Object autoname xoxsdobj] 
	namespace eval $ns $type $obj $args
	return "$ns\::$obj"
}

XSDObject instproc lookupObject {name} {
	set i 1
	set ns ""
	while { ![Object isobject "$ns\::$name"] } {
		# get the caller's namespace:
		set ns [uplevel [incr i] namespace current]
	}
	return "$ns\::$name"
}

XSDObject instproc trySetContent {text} {
	if { [Object isobject $text] } {
		return false
	}
	if { [lsearch [my attributes] "*::__text"] != -1 } {
		my __text $text
		return true
	}
	return false
}

}

